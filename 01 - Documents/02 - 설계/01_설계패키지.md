# 02_01 · 설계 패키지(플로우/ERD) – MediGo

> 문제 2 · 사용자 흐름과 기술 설계를 동결

## 1. 유저 플로우(User Flow)
- 핵심 시나리오 1: 처방전 발급 → 알림 → 약국 선택 → 배달 현황 확인  
  1) 사용자가 병원에서 처방전을 발급받는다.  
  2) 잠금 화면에 "처방전이 발급되었습니다" 알림이 도착한다.  
  3) 알림을 탭하면 MediGo 앱 화면으로 진입한다.  
  4) 사용자는 처방전 카드에서 내용을 확인하고 "수령 지역 선택하기" 버튼을 누른다.  
  5) 지도/검색 화면에서 "서울시청" 등 수령 지역을 검색한다.  
  6) 리스트에서 배달 가능한 약국을 선택하고 주문을 생성한다.  
  7) 배달 진행 화면에서 라이더의 이동 경로와 ETA를 확인한다.  
  8) 배송 완료 시 완료 카드와 토스트 메시지를 본다.

## 2. 와이어프레임 / 화면 설계
- 모바일 잠금/홈 화면  
  - 큰 시계 + 날짜, 하단 알림 배너  
  - "위로 쓸어올려서 잠금 해제" 텍스트와 제스처 인디케이터  
- 메인 앱 화면(처방전 카드)  
  - 상단 주문 정보 카드: 주문번호, 상태 뱃지  
  - 중간 처방전 카드: 썸네일 이미지, OCR 상태, "수령 지역 선택하기" 버튼  
- 위치/약국 선택 화면  
  - 검색 인풋 + 검색 버튼  
  - "모두 모아보기" 버튼  
  - 지도(Leaflet) + 약국 리스트(카드 형식, "재고 확인/배달가능" 버튼)  
- 배달 현황 화면  
  - 상단 상태 뱃지 + ETA  
  - 두 번째 지도: 라이더 아이콘 이동 애니메이션  
  - 하단 배송 완료 사진/인증 이미지
> 실제 구현은 `web/index.html`/`style.css`/`app.js` 구조를 기준으로 설계됨.

## 3. 아키텍처 다이어그램
- 클라이언트  
  - 정적 웹(`web/`) – Leaflet 지도, MediGo UI  
  - 데스크톱 exe – `desktop.py` + pywebview, 내부에서 uvicorn 백엔드 기동  
- 서버  
  - FastAPI(Uvicorn) – `backend/app/main.py`  
  - API: `/api/pharmacies`, `/api/orders`, `/api/prescriptions`, `/health`  
- 데이터  
  - SQLite(`~/.medigo/db.sqlite`) – SQLAlchemy ORM 사용  
  - 시드 스크립트(`seed.py`)로 약국 기본 데이터 삽입  
- 외부 연동  
  - 현재 없음. 향후 Kakao톡 로그인/알림, 병원/약국 EMR 연동을 위한 어댑터 레이어 추가 예정.

## 4. 데이터 모델(ERD 요약)
- 핵심 테이블
  - `pharmacies`: 약국 정보
  - `orders`: 주문/배달 상태
  - `prescriptions`: 처방전 파일 메타데이터
- 관계 설명  
  - `orders.pharmacy_id` → `pharmacies.id` (N:1)  
  - `prescriptions`는 현 MVP에서는 주문과 직접 연결되어 있지 않지만, 향후 `orders.prescription_id` FK 추가 예정.

## 5. 시퀀스 다이어그램(예시)
### 5.1 "처방전 업로드 → 약국 선택 → 주문 생성"
- Actor/시스템 간 메시지 흐름 정리  
  1) 사용자가 프런트에서 처방전 파일을 업로드한다.  
  2) 프런트 → 백엔드: `POST /api/prescriptions` (multipart) 요청.  
  3) 백엔드: 업로드 파일을 저장하고 `prescriptions` 테이블에 레코드 생성.  
  4) 사용자가 "수령 지역 선택하기" 버튼을 클릭한다.  
  5) 프런트 → 백엔드: `GET /api/pharmacies` 또는 `/api/pharmacies/search` 호출.  
  6) 백엔드: `pharmacies` 테이블 조회 후 결과 반환.  
  7) 사용자가 약국을 선택하고 "배달 시작"을 누른다.  
  8) 프런트 → 백엔드: `POST /api/orders` 요청.  
  9) 백엔드: `orders`에 레코드 생성, 라우팅 정보와 ETA 계산 후 응답.  
  10) 프런트: 응답의 `route`를 사용해 지도에서 라이더 애니메이션을 시작한다.

